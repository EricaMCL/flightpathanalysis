# -*- coding: utf-8 -*-

"""
/***************************************************************************
 flightPathAnalysis
                                 A QGIS plugin
 Analysis the flight path impact on UWR
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-28
        copyright            : (C) 2023 by Erica Liu
        email                : halamay1029@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Erica Liu'
__date__ = '2023-02-28'
__copyright__ = '(C) 2023 by Erica Liu'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import datetime
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterString,
                       QgsProcessingParameterField,
                       QgsProcessingParameterDistance,
                       QgsProcessingFeedback,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterMultipleLayers,
                       QgsField,
                       QgsFeature,
                       QgsVectorLayer,
                       QgsCoordinateReferenceSystem,
                       QgsVectorFileWriter,
                       QgsException)
import glob
import os

import pandas as pd
import processing
from .flightPathAnalysis_Function_QGIS import rawBuffer, findBufferRange, replaceNonAlphaNum, convert_timedelta, makeViewshed
import shutil
from pathlib import Path


class createUWRBuffer(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    origUWR = 'origUWR'
    projectFolder = 'projectFolder'
    unit_id = 'unit_id'
    unit_id_no = 'unit_id_no'
    buffDistIS_high = 'buffDistIS_high'
    buffDistIS_moderate = 'buffDistIS_moderate'
    buffDistIS_low = 'buffDistIS_low'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # OrigUWR - Input vector polygon
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.origUWR, self.tr('Input original UWR'), [QgsProcessing.TypeVectorPolygon]))
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # unit_id / unit_id_no - Input string
        # User selects from the field list derived from OrigUWR
        # ===========================================================================
        self.addParameter(QgsProcessingParameterField(
            self.unit_id, self.tr('Input unit id field, column has text like u-2-002'), 'unit_id', self.origUWR))

        self.addParameter(QgsProcessingParameterField(
            self.unit_id_no, self.tr('Input unit id number field, column has text like Mg-059'), 'unit_id', self.origUWR))
        # ===========================================================================
        # bufferDistIS_high/moderate/low - Input string, with default value 500/1000/1500
        # three buffer range represents different incursion severity range
        # ===========================================================================
        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_high, self.tr('Buffer distance - High Incursion Severity'), 500))

        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_moderate, self.tr('Buffer distance - Moderate Incursion Severity'), 1000))

        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_low, self.tr('Buffer distance - Low Incursion Severity'), 1500))


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        origUWR_source = self.parameterAsSource(parameters, self.origUWR, context)
        origUWR = parameters['origUWR']
        projectFolder = parameters['projectFolder']
        feedback.setProgressText(str(origUWR))
        uwrBufferedPath = os.path.join(projectFolder, 'uwrBuffered')
        delFolder = os.path.join(projectFolder, 'delFolder')
        final = None

        try:

            if os.path.exists(delFolder):
                try:
                    shutil.rmtree(delFolder)
                    os.mkdir(delFolder)
                except:
                    feedback.setProgressText('unable to delete delFolder')
            else:
                os.mkdir(delFolder)

            # ==============================================================
            # unit_no, eg. u-2-002
            # unit_no_id, eg. Mg-106
            # unit_unique_field, field that combines uwr number and uwr unit number
            # ==============================================================
            unit_no = parameters['unit_id']
            unit_no_id = parameters['unit_id_no']
            uwr_unique_Field = "uwr_unique_id"

            bufferDistList = [int(parameters['buffDistIS_high']), int(parameters['buffDistIS_moderate']),
                              int(parameters['buffDistIS_low'])]
            feedback.setProgressText(str(bufferDistList))

            # ===========================================================================
            # Check if the input vector includes invalid geometry
            # ===========================================================================
            result = processing.run("qgis:checkvalidity", {
                'INPUT_LAYER': parameters['origUWR']})
            errorCount = result['ERROR_COUNT']
            feedback.setProgressText(str(errorCount))

            # ===========================================================================
            # Fix the input geometry if invalid found, and replace the input for further process
            # ===========================================================================
            if errorCount > 0:
                fixGeom = processing.run("native:fixgeometries",
                                         {'INPUT': parameters['origUWR'],
                                          'OUTPUT': 'TEMPORARY_OUTPUT'})
                feedback.setProgressText('Geometry fixed')
                origUWR = fixGeom['OUTPUT']

            else:
                fixGeom = processing.run("native:fixgeometries",
                                         {'INPUT': parameters['origUWR'],
                                          'OUTPUT': 'TEMPORARY_OUTPUT'})
                feedback.setProgressText('Geometry fixed')
                origUWR = fixGeom['OUTPUT']


            # ==============================================================
            # Get list of relevant UWR
            # ==============================================================
            origUWRFieldList = origUWR.fields().names()
            unit_no_index = origUWRFieldList.index(unit_no)
            unit_no_id_index = origUWRFieldList.index(unit_no_id)
            feedback.setProgressText(f'{unit_no_id_index, unit_no_index}')
            uwrSet = set()
            for feature in origUWR.getFeatures():
                uwr_unique_Field_value = f'{feature.attributes()[unit_no_index]}__{feature.attributes()[unit_no_id_index]}'
                uwrSet.add(uwr_unique_Field_value)
                #feedback.setProgressText(f'{uwr_unique_Field_value} added and updated')

            feedback.setProgressText(f'{uwr_unique_Field} added and updated')
            feedback.setProgressText(f'{uwrSet} added and updated')

            # ==============================================================
            # Check existence of uwrBuffered in project folder
            # ==============================================================
            uwrBuffered_exist = os.path.isfile(uwrBufferedPath + '.gpkg')

            # ==============================================================
            # Get list of uwr that have buffers created
            # ==============================================================
            if uwrBuffered_exist:
                feedback.setProgressText(f'uwrBuffered exists in project folder.')
                createdUWRSet = set()
                uwrBuffered_layer = QgsVectorLayer((uwrBufferedPath + '.gpkg'), "uwrBuffered", "ogr")
                uwrBufferedFieldList = uwrBuffered_layer.fields().names()
                feedback.setProgressText(f'{uwrBufferedFieldList}')
                uwr_unique_Field_index = uwrBufferedFieldList.index(uwr_unique_Field)
                feedback.setProgressText(f'{uwrBufferedFieldList}')
                for feature in uwrBuffered_layer.getFeatures():
                    uwr_unique_Field_value =  f'{feature.attributes()[uwr_unique_Field_index]}'
                    createdUWRSet.add(uwr_unique_Field_value)

                uwrRequireSet = uwrSet - createdUWRSet
                feedback.setProgressText(f'{uwrSet} --uwrSet')
                feedback.setProgressText(f'{createdUWRSet} -- createdUWRSet')
                feedback.setProgressText(f'{uwrRequireSet} --uwrRequireSet')

            else:
                uwrRequireSet = uwrSet
                feedback.setProgressText(f'uwrBuffered NOT exists in project folder.')


            if len(uwrRequireSet) > 0:
                if uwrBuffered_exist:
                # ==============================================================
                # Make new field in copy of orig UWR FC for unique UWR id.
                # DIFFERENT FROM unique uwr id. make it so that there's no way this field existed before
                # ==============================================================
                    tempUniqueUWRField = 'tempUniqueUWRField'
                    if tempUniqueUWRField not in origUWRFieldList:
                        tempGPKG = processing.run("native:fieldcalculator",
                                                  {'FIELD_LENGTH': 100,
                                                   'FIELD_NAME': tempUniqueUWRField,
                                                   'NEW_FIELD': True,
                                                   'FIELD_PRECISION': 0,
                                                   'FIELD_TYPE': 2,
                                                   'FORMULA': f' "{unit_no}" + \'__\' + "{unit_no_id}" ',
                                                   'INPUT': origUWR,
                                                   'OUTPUT': 'TEMPORARY_OUTPUT'}, context=context, feedback=feedback)['OUTPUT']


                    # ==============================================================
                    # Select require uwr by making query with uwrRequireSet
                    # ==============================================================
                    uwrList_String = "','".join(uwrRequireSet)
                    unbufferedFL = os.path.join(projectFolder, 'unbufferedUWR')
                    expression = tempUniqueUWRField + " in ('" + uwrList_String + "')"
                    unbufferedFLPath = processing.run("native:extractbyexpression",
                                   {'EXPRESSION': expression,
                                    'INPUT': tempGPKG,
                                    'OUTPUT': unbufferedFL})['OUTPUT']
                    feedback.setProgressText(f'unBufferedUWR created in {unbufferedFL}')
                    requireUWRLayer = unbufferedFLPath
                else:
                    requireUWRLayer = origUWR
                    feedback.setProgressText('requireUWRLayer = origUWR')

                # ==============================================================
                # Dissolves input feature class by dissolveFields list if list is given
                # This is to avoid errors for multi-part uwr that have been split into
                # separate features in the original uwr feature class.
                # ==============================================================
                dissolvedOrigPath = os.path.join(projectFolder, 'dissolve')
                dissolvedOrig = processing.run("native:dissolve",
                                               {'FIELD': [unit_no, unit_no_id],
                                                'INPUT': requireUWRLayer,
                                                'OUTPUT': 'TEMPORARY_OUTPUT',
                                                'SEPARATE_DISJOINT': False})['OUTPUT']
                dissolvedOrig_fid_removed = processing.run("native:deletecolumn",
                                               {'COLUMN': ['fid'],
                                                'INPUT': dissolvedOrig,
                                                'OUTPUT': dissolvedOrigPath})['OUTPUT']

                # ============re==================================================
                # Start list of intermediate features to be deleted
                # ==============================================================
                uwrOnly = "BufferUWROnly"
                delFC = [os.path.join(projectFolder, uwrOnly)]

                # ==============================================================
                # Create raw buffers
                # ==============================================================
                rawBufferDict = {}
                for bufferDist in bufferDistList:
                    rawBufferLoc, rawBufferName = rawBuffer(projectFolder, 'dissolve.gpkg',
                                                  str(bufferDist) + 'Meters', bufferDist, delFolder,
                                                      unit_no, unit_no_id, uwr_unique_Field)
                    rawBufferDict[bufferDist] = [rawBufferLoc, rawBufferName]
                    delFC.append(os.path.join(rawBufferLoc, rawBufferName))
                    feedback.setProgressText(f"raw buffer created, {rawBufferName}")

                # ==============================================================
                # Get donut shaped buffer to only get list of buffered donut polygons
                # that will be merge together to the final layer
                # ==============================================================
                requireMergeBufferList = []

                # ==============================================================
                # Go through each buffer distance to get the donut shapes of
                # only the area for each buffer distance
                # ==============================================================
                uniqueIDFields = [unit_no, unit_no_id]
                sortBufferDistList = list(sorted(bufferDistList))
                feedback.setProgressText(f'{sortBufferDistList} -- sortedBuffer')
                for bufferDist in sortBufferDistList:
                    ToEraseLoc = rawBufferDict[bufferDist][0]
                    ToEraseName = rawBufferDict[bufferDist][1] + '.gpkg'
                    ToErasePath = os.path.join(ToEraseLoc, ToEraseName)
                    feedback.setProgressText(f'{ToEraseLoc} and {ToEraseName}')
                    feedback.setProgressText(f'{bufferDist} -- Bufferdist')

                    if sortBufferDistList.index(bufferDist) == 0:
                        onlyBufferDist = findBufferRange(dissolvedOrig_fid_removed, ToErasePath, uniqueIDFields, delFolder, bufferDist)
                        feedback.setProgressText(f'UseToErasePath - {dissolvedOrig_fid_removed}')
                        feedback.setProgressText(f'ToErasePath - {ToErasePath}')
                    else:
                        prevIndex = sortBufferDistList.index(bufferDist) - 1
                        prevBufferDist = sortBufferDistList[prevIndex]
                        prevBufferPath = os.path.join(rawBufferDict[prevBufferDist][0], rawBufferDict[prevBufferDist][1] + '.gpkg')
                        feedback.setProgressText(prevBufferPath)
                        feedback.setProgressText(f'UseToErasePath - {prevBufferPath}')
                        feedback.setProgressText(f'ToErasePath - {ToErasePath}')
                        onlyBufferDist = findBufferRange(prevBufferPath, ToErasePath, uniqueIDFields, delFolder, bufferDist)

                    requireMergeBufferList.append(onlyBufferDist)
                    feedback.setProgressText(f'appended uwronly{onlyBufferDist} -- onlyBufferDist')

                # ==============================================================
                # Create bufferUWROnly_NEW with uwr_unique_field and BUFF_DIST fields
                # ==============================================================
                uwrOnlyNewPath = os.path.join(projectFolder, uwrOnly)
                uwrOnly_new = processing.run("native:savefeatures",
                                               {'INPUT': dissolvedOrig_fid_removed,
                                                'OUTPUT': 'TEMPORARY_OUTPUT',
                                                'LAYER_NAME': '',
                                                'DATASOURCE_OPTIONS': '',
                                                'LAYER_OPTIONS': ''})['OUTPUT']

                uwrOnly_new_uniField = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 100,
                                        'FIELD_NAME': uwr_unique_Field,
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 0,
                                        'FIELD_TYPE': 2,
                                        'FORMULA': f' "{unit_no}" + \'__\' + "{unit_no_id}" ',
                                        'INPUT': uwrOnly_new,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'}, context=context, feedback=feedback)['OUTPUT']

                uwrOnly_new_uniField_buffDist = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 100,
                                        'FIELD_NAME': 'BUFF_DIST',
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 0,
                                        'FIELD_TYPE': 0,
                                        'FORMULA': 0,
                                        'INPUT': uwrOnly_new_uniField,
                                        'OUTPUT': uwrOnlyNewPath}, context=context, feedback=feedback)['OUTPUT']
                requireMergeBufferList.append(uwrOnly_new_uniField_buffDist)

                feedback.setProgressText(f'{uwrOnly_new_uniField_buffDist} created')

                # ==============================================================
                # Append uwr into the final geopackage or create a new one
                # ==============================================================
                if uwrBuffered_exist:
                    requireMergeBufferList.append(uwrBuffered_layer)
                    final = processing.run("native:mergevectorlayers",
                                           {'LAYERS': requireMergeBufferList,
                                            'OUTPUT': uwrBufferedPath + '_updated'})['OUTPUT']
                    os.remove(uwrBufferedPath + '.gpkg')
                    os.rename(final, uwrBufferedPath + '.gpkg')
                    feedback.setProgressText('final geopackage exists')
                else:
                    final = processing.run("native:mergevectorlayers",
                                           {'LAYERS': requireMergeBufferList,
                                            'OUTPUT': uwrBufferedPath})['OUTPUT']
                    for f in requireMergeBufferList:
                        feedback.setProgressText(f'{f} merged')


            else:
                feedback.setProgressText(f'No Need to create uwr buffers')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            #shutil.rmtree(delFolder)
            #feedback.setProgressText(f'{delFolder} deleted')
            feedback.setProgressText('Completed')


        # ===========================================================================
        # Calculate the uwr_unique_id field value
        # ===========================================================================

        total = 100.0 / origUWR_source.featureCount() if origUWR_source.featureCount() else 0
        features = origUWR_source.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return  {'uwrBuffered': final}


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '1. Create UWR buffer'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return createUWRBuffer()

class flightPathConvert(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    projectFolder = 'projectFolder'
    gpxFolder = 'gpxFolder'
    uwrBuffered = 'uwrBuffered'
    unit_id = 'unit_id'
    unit_id_no = 'unit_id_no'
    DEM = 'DEM'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # uwrBuffered
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.uwrBuffered, self.tr('Input uwrBuffered'), [QgsProcessing.TypeVectorPolygon]))

        # ===========================================================================
        # gpx - Input Folder
        # will loop through all the gpx files under the folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.gpxFolder, self.tr('Input gpx folder'), QgsProcessingParameterFile.Folder))

        # ===========================================================================
        # unit_id / unit_id_no - Input string
        # User selects from the field list derived from OrigUWR
        # ===========================================================================
        self.addParameter(QgsProcessingParameterField(
            self.unit_id, self.tr('Input unit id field, column has text like u-2-002'), 'unit_id', self.uwrBuffered))

        self.addParameter(QgsProcessingParameterField(
            self.unit_id_no, self.tr('Input unit id field, column has text like Mg-059'), 'unit_id_no', self.uwrBuffered))

        # ===========================================================================
        # DEM
        # ===========================================================================
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.DEM, self.tr('Input the project DEM')))

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        projectFolder = parameters['projectFolder']
        uwrBuffered = self.parameterAsSource(parameters, self.uwrBuffered, context)
        uwrBufferedPath = parameters['uwrBuffered']
        gpxFolder = parameters['gpxFolder']
        DEM = parameters['DEM']
        delFolder = os.path.join(projectFolder, 'delFolder')

        # ==============================================================
        # incursionSeverity will be created using the user input from create buffer step
        # the following parts will be replaced by user input when combined steps
        # ==============================================================
        inUWR_IS = 0
        high_IS = 500
        moderate_IS = 1000
        low_IS = 1500
        incursionSeverity = {inUWR_IS: "In UWR", high_IS: "High", moderate_IS: "Moderate", low_IS: "Low"}
        feedback.setProgressText(str(uwrBuffered))

        # ==============================================================
        # unit_no, eg. u-2-002
        # unit_no_id, eg. Mg-106
        # unit_unique_field, field that combines uwr number and uwr unit number
        # ==============================================================
        unit_no = parameters['unit_id']
        unit_no_id = parameters['unit_id_no']
        uwr_unique_Field = "uwr_unique_id"

        # ==============================================================
        # Create variables for converting all gpx files into fc
        # timeIntervalDict - dictionary of different time intervals and the flight points in each
        # flightLines - lists of flight lines
        # flightCount - count of flight lines
        # totalSeasonTime- total flight time in the season
        # checkFilesList - checkFilesList
        # ==============================================================
        timeIntervalDict = {}
        flightLines = []
        flightCount = 0
        totalSeasonTime = 0
        checkFilesList = []

        # ===========================================================================
        # Loop through the input GPX folder
        # ===========================================================================
        gpxFiles = glob.glob(os.path.join(gpxFolder, "*.gpx"))
        gpxTemps = []

        try:
            # ===========================================================================
            # Check if the delFolder exists, and delete it if found
            # ===========================================================================
            if os.path.exists(delFolder):
                try:
                    shutil.rmtree(delFolder)
                    os.mkdir(delFolder)
                except:
                    feedback.setProgressText('unable to delete delFolder')
            else:
                os.mkdir(delFolder)

            # ===========================================================================
            # Get the row count of each GPX file, and the required information from different layers
            # ===========================================================================
            for gpxFile in gpxFiles:
                flightCount += 1
                feedback.setProgressText(f'{str(flightCount)}: {str(gpxFile)}')
                gpxFormattedName = replaceNonAlphaNum(Path(gpxFile).stem, '_')
                feedback.setProgressText(f'{gpxFormattedName}')

                gpxDict = {'tkpt': '|layername=track_points', 'tkline': '|layername=tracks'}
                rowCount = processing.run("qgis:basicstatisticsforfields",
                                          {'INPUT_LAYER': gpxFile + gpxDict['tkpt'],
                                           'FIELD_NAME': 'time',
                                           'OUTPUT_HTML_FILE': 'TEMPORARY_OUTPUT'})['COUNT']
                tkLyr = QgsVectorLayer((gpxFile + gpxDict['tkline']), "", "ogr")
                tkLyrNameIndex = (tkLyr.fields().names()).index('name')
                if tkLyrNameIndex != None:
                    tkLyrFeatures = tkLyr.getFeatures()
                    for feature in tkLyrFeatures:
                        tkLyrName = str(feature.attributes()[tkLyrNameIndex])
                        feedback.setProgressText(f'{tkLyrName}')
                feedback.setProgressText(f'{rowCount}')

                # ==============================================================
                # Checks for files with consistent time intervals.
                #  - All fc with same time intervals are grouped together in the dictionary
                #  - If there are more than 2 rows
                #       - find time between point recorded halfway through the flight and the point recorded right before it.
                #       - else,time for objectid 3 - objectid 2 because there was an instance where there were 4 minutes between id 1 and 2.
                #         assume only seconds between them the two points
                # ==============================================================
                tkptLyr_id = processing.run("native:fieldcalculator",
                                            {'FIELD_LENGTH': 100,
                                             'FIELD_NAME': 'OBJECTID',
                                             'NEW_FIELD': True,
                                             'FIELD_PRECISION': 0,
                                             'FIELD_TYPE': 0,
                                             'FORMULA': '@id',
                                             'INPUT': gpxFile + gpxDict['tkpt'],
                                             'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                query = None
                if int(rowCount) > 2:
                    half = round(int(rowCount) / 2)
                    sel = (half - 1, half)
                    query = "OBJECTID in " + str(sel)
                elif int(rowCount) == 2:
                    half = round(int(rowCount) / 2)
                    sel = (half - 1, half)
                    query = "OBJECTID in (0,1)"
                else:
                    checkFilesList.append(gpxFile)
                    continue

                if query != None:
                    tkptLyrExtracted = processing.run("native:extractbyexpression",
                                                    {'EXPRESSION': query,
                                                     'INPUT': tkptLyr_id,
                                                     'OUTPUT': os.path.join(delFolder, 'tkptExtracted' + str(flightCount))})['OUTPUT']
                    tkptLyr = QgsVectorLayer((tkptLyrExtracted), "", "ogr")
                    tkptExtractedTimeIndex = (tkptLyr.fields().names()).index('time')
                    features = tkptLyr.getFeatures()
                    values = []
                    # ==============================================================
                    # Calculate the time interval and the totalFlightTime
                    # ==============================================================
                    for f in features:
                        timeValue = f.attributes()[tkptExtractedTimeIndex]
                        values.append(timeValue)
                    timeInterval = values[1].toTime_t() - values[0].toTime_t()
                    totalFlightTime = rowCount * timeInterval
                    feedback.setProgressText(f'The total flight time of {gpxFormattedName} is {totalFlightTime} seconds')


                # ===========================================================================
                # Add the Name field from tracks layer to track points layer
                # ===========================================================================
                gpxTempPath = os.path.join(delFolder, 'temp_' + gpxFormattedName)
                feedback.setProgressText(f'{gpxTempPath}')
                gpxTemp_saved = processing.run("native:savefeatures",
                                               {'INPUT': gpxFile + gpxDict['tkpt'],
                                                'OUTPUT': 'TEMPORARY_OUTPUT',
                                                'LAYER_NAME': '',
                                                'DATASOURCE_OPTIONS': '',
                                                'LAYER_OPTIONS': ''})['OUTPUT']

                gpxField_name_new = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 30,
                                        'FIELD_NAME': 'NameTkline',
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 0,
                                        'FIELD_TYPE': 2,
                                        'FORMULA':  f"'{tkLyrName}'",
                                        'INPUT': gpxTemp_saved,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

                # ===========================================================================
                # Add the flightName field
                # ===========================================================================
                gpxField_flightName = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 100,
                                        'FIELD_NAME': 'FlightName',
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 0,
                                        'FIELD_TYPE': 2,
                                        'FORMULA':  f"'{gpxFormattedName}'",
                                        'INPUT': gpxField_name_new,
                                        'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']


                # ===========================================================================
                # Add the TotalTime field
                # ===========================================================================
                gpxTemp = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 100,
                                        'FIELD_NAME': 'TotalTime',
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 2,
                                        'FIELD_TYPE': 0,
                                        'FORMULA':  f"'{totalFlightTime}'",
                                        'INPUT': gpxField_flightName,
                                        'OUTPUT': gpxTempPath}, context=context, feedback=feedback)['OUTPUT']

                gpxTemps.append(gpxTemp)

                # ===========================================================================
                # Create flight line
                # ===========================================================================
                flightLineName = gpxFormattedName + '__flightLine'
                flightLinePath = os.path.join(delFolder, flightLineName)
                flightline = processing.run("native:pointstopath",
                                            {'INPUT':gpxTemp,
                                             'CLOSE_PATH':False,
                                             'ORDER_EXPRESSION':'',
                                             'NATURAL_SORT':False,
                                             'GROUP_EXPRESSION':'',
                                             'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

                flightLineNameField = processing.run("native:fieldcalculator",
                                       {'FIELD_LENGTH': 100,
                                        'FIELD_NAME': 'Name',
                                        'NEW_FIELD': True,
                                        'FIELD_PRECISION': 0,
                                        'FIELD_TYPE': 2,
                                        'FORMULA':  f"'{tkLyrName}'",
                                        'INPUT': flightline,
                                        'OUTPUT': flightLinePath})['OUTPUT']
                flightLines.append(flightLineNameField + f'|layername={flightLineName}')
                feedback.setProgressText(f'Flight Line: {flightLineNameField} appended')

                # ===========================================================================
                # Get season time sum
                # ===========================================================================
                totalSeasonTime += totalFlightTime
                timeIntervalStr = "T" + replaceNonAlphaNum(str(timeInterval), "_")
                if timeIntervalStr not in timeIntervalDict:
                    timeIntervalDict[timeIntervalStr] = [timeInterval, [gpxTemp]]
                else:
                    timeIntervalDict[timeIntervalStr][1].append(gpxTemp)
                feedback.setProgressText(f'===========================================')


            # ===========================================================================
            # Output the problem text to the gpx folder
            # ===========================================================================
            if len(checkFilesList) > 0:
                problemGPXText = open(os.path.join(projectFolder, 'problemGPXFiles.txt'), "w")
                for i in checkFilesList:
                    problemGPXText.write(i + "\n")
                problemGPXText.close()

            feedback.setProgressText(f'Total season time : {totalSeasonTime}')
            feedback.setProgressText(f'Total flight line {flightCount}')
            feedback.setProgressText(f'Number of different time interval {len(timeIntervalDict)}')
            feedback.setProgressText(f'{timeIntervalDict}')

            # ===========================================================================
            # Unprojected
            # ===========================================================================
            unprojectedGPX = []
            for interval in timeIntervalDict:
                gpxAllUnprojectedPath = os.path.join(delFolder, interval + '_All_unprojected')
                gpxMergeUnprojected = processing.run("native:mergevectorlayers",
                                        {'LAYERS': timeIntervalDict[interval][1],
                                         'CRS': None,
                                         'OUTPUT': os.path.join(delFolder, 'mergeUnprojected')})['OUTPUT']

                feedback.setProgressText(f'Merged all gpx file for {interval}')

                # ===========================================================================
                # Reproject GPX merge lyr, and create a dem extent to down the orig DEM
                # ===========================================================================
                gpxMergePprojected = processing.run("grass7:v.proj",
                                                             {'input': gpxMergeUnprojected,
                                                              'crs': QgsCoordinateReferenceSystem('EPSG:3005'),
                                                              'smax': 10000, '-z': False, '-w': False,
                                                              'output': os.path.join(delFolder, 'mergeProjected.gpkg'),
                                                              'GRASS_REGION_PARAMETER': None,
                                                              'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
                                                              'GRASS_MIN_AREA_PARAMETER': 0.0001,
                                                              'GRASS_OUTPUT_TYPE_PARAMETER': 0,
                                                              'GRASS_VECTOR_DSCO': '',
                                                              'GRASS_VECTOR_LCO': '',
                                                              'GRASS_VECTOR_EXPORT_NOCAT': False})['output']

                gpxMergePprojected_extent = processing.run("native:polygonfromlayerextent",
                               {'INPUT': gpxMergePprojected,
                                'ROUND_TO': 0, 'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                demExtent = processing.run("native:buffer", {
                    'INPUT': gpxMergePprojected_extent,
                    'DISTANCE': 100, 'SEGMENTS': 90, 'END_CAP_STYLE': 2, 'JOIN_STYLE': 0, 'MITER_LIMIT': 2,
                    'DISSOLVE': False, 'OUTPUT': os.path.join(delFolder, 'gpxMergeProjected_extent')})['OUTPUT']

                demClipped = processing.run("gdal:cliprasterbymasklayer",
                                            {'INPUT':DEM,
                                             'MASK':demExtent,
                                             'SOURCE_CRS':None,'TARGET_CRS':None,'TARGET_EXTENT':None,'NODATA':None,'ALPHA_BAND':False,'CROP_TO_CUTLINE':True,
                                             'KEEP_RESOLUTION':True,'SET_RESOLUTION':False,'X_RESOLUTION':None,'Y_RESOLUTION':None,'MULTITHREADING':False,
                                             'OPTIONS':'','DATA_TYPE':0,'EXTRA':'','OUTPUT':os.path.join(delFolder, 'demElev.tif')})['OUTPUT']
                # ===========================================================================
                # Extract the elevation values to points, default field name: DEMelev
                # ===========================================================================
                DEMElev = processing.run("sagang:addrastervaluestopoints",
                               {'SHAPES': gpxMergePprojected,
                                'GRIDS': [demClipped],
                                'RESULT': 'TEMPORARY_OUTPUT',
                                'RESAMPLING': 3})['RESULT']
                feedback.setProgressText(f'DEM extract value to point')

                AGL = processing.run("native:fieldcalculator",
                                            {'INPUT':DEMElev,
                                             'FIELD_NAME':'AGL',
                                             'FIELD_TYPE':1,
                                             'FIELD_LENGTH':100,
                                             'FIELD_PRECISION':0,
                                             'FORMULA':'case\r\nwhen "ele" - "demElev" <0 then 0 \r\nelse "ele" - "demElev"\r\nend\r\n\r\n',
                                             'OUTPUT':gpxAllUnprojectedPath})['OUTPUT']
                # ===========================================================================
                # Create layer with only points less than 500m
                # ===========================================================================
                pointLessthan500m_UnprojectedPath = os.path.join(delFolder,'PointLessthan500m_Unprojected' + interval)
                pointLessthan500mExtracted = processing.run("native:extractbyexpression",
                                                  {'EXPRESSION': '"AGL" < 500',
                                                   'INPUT': AGL,
                                                   'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                rowCount = processing.run("qgis:basicstatisticsforfields",
                                          {'INPUT_LAYER': pointLessthan500mExtracted,
                                           'FIELD_NAME': 'time',
                                           'OUTPUT_HTML_FILE': 'TEMPORARY_OUTPUT'})['COUNT']
                feedback.setProgressText(f'point less than 500, row count: {rowCount}')
                if rowCount == 0:
                    feedback.setProgressText(f'point less than 500m layer table is empty')
                    continue

                # ===========================================================================
                # Add time interval field
                # ===========================================================================
                timeIntervalField = processing.run("native:fieldcalculator",
                                            {'INPUT':pointLessthan500mExtracted,
                                             'FIELD_NAME':'TimeInterval',
                                             'FIELD_TYPE':0,
                                             'FIELD_LENGTH':100,
                                             'FIELD_PRECISION':0,
                                             'FORMULA':f"'{timeIntervalDict[interval][0]}'",
                                             'OUTPUT':pointLessthan500m_UnprojectedPath})['OUTPUT']
                feedback.setProgressText(f'TimeInterval field added')
                unprojectedGPX.append(timeIntervalField + f'|layername=PointLessthan500m_Unprojected{interval}')
                feedback.setProgressText(f'Unprojected layer:{timeIntervalField} appended')
            feedback.setProgressText(f'{unprojectedGPX}')

            # ===========================================================================
            # Merge all unprojectedGPS layers that includes points below 500m
            # ===========================================================================
            if len(unprojectedGPX) > 1:
                gpxMergeUnprojected_500m = processing.run("sagang:mergevectorlayers", {
                'INPUT': unprojectedGPX,
                'MERGED': os.path.join(delFolder, 'pointLessthan500m_Unprojected_Final'),
                'SRCINFO': False,
                'MATCH': True,
                'DELETE': False})['MERGED'] + '.shp'
            else:
                gpxMergeUnprojected_500m = unprojectedGPX[0]


            feedback.setProgressText(f'{gpxMergeUnprojected_500m} created')
            # ===========================================================================
            # Remove blank fields from gpxMergeUnprojected_500m_Final
            # ===========================================================================
            gpxMergeUnprojected_500m_reprojected = processing.run("native:refactorfields",
                                                {'INPUT':gpxMergeUnprojected_500m,
                                                'FIELDS_MAPPING':[{'expression': '"cat"','length': 16,'name': 'cat','precision': 0,'sub_type': 0,'type': 4,'type_name': 'int8'},
                                                                  {'expression': '"ele"','length': 18,'name': 'ele','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                                  {'expression': '"time"','length': 23,'name': 'time','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                                  {'expression': '"hdop"','length': 18,'name': 'hdop','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                                  {'expression': '"badelf_spe"','length': 18,'name': 'badelf_spe','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                                  {'expression': '"NameTkline"','length': 35,'name': 'NameTkline','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                                  {'expression': '"FlightName"','length': 34,'name': 'FlightName','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                                  {'expression': '"TotalTime"','length': 18,'name': 'TotalTime','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                                  {'expression': '"layer"','length': 39,'name': 'layer','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                                  {'expression': '"demElev"','length': 18,'name': 'demElev','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                                  {'expression': '"AGL"','length': 16,'name': 'AGL','precision': 0,'sub_type': 0,'type': 4,'type_name': 'int8'},
                                                                  {'expression': '"TimeInterval"','length': 18,'name': 'TimeInterval','precision': 10,'sub_type': 0,'type': 6,'type_name': 'double precision'}],
                                                 'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']

            # ===========================================================================
            # Reproject the result to ESPG 3005
            # ===========================================================================
            feedback.setProgressText(f'Reprojecting allFlightPoints....')
            pointLessthan500m_Projected = processing.run("grass7:v.proj",
                                                         {'input':gpxMergeUnprojected_500m_reprojected,
                                                         'crs':QgsCoordinateReferenceSystem('EPSG:3005'),
                                                          'smax':10000,'-z':False,'-w':False,
                                                          'output':os.path.join(projectFolder, 'pointLessthan500m_Projected.gpkg'),
                                                          'GRASS_REGION_PARAMETER':None,
                                                          'GRASS_SNAP_TOLERANCE_PARAMETER':-1,
                                                          'GRASS_MIN_AREA_PARAMETER':0.0001,
                                                          'GRASS_OUTPUT_TYPE_PARAMETER':0,
                                                          'GRASS_VECTOR_DSCO':'',
                                                          'GRASS_VECTOR_LCO':'',
                                                          'GRASS_VECTOR_EXPORT_NOCAT':False})['output']
            feedback.setProgressText(f'Reprojected allFlightPoints')

            # ===========================================================================
            # Merge all the flight lines
            # ===========================================================================
            gpxMergeFlightLines = processing.run("native:mergevectorlayers",
                                    {'LAYERS': flightLines,
                                    'CRS': None,
                                    'OUTPUT': os.path.join(delFolder, 'allFlightLinesUnprojected')})['OUTPUT']
            feedback.setProgressText(f'Reprojecting allFlightLines....')

            allFlightLines_Projected = processing.run("grass7:v.proj",
                                                         {'input': gpxMergeFlightLines,
                                                          'crs': QgsCoordinateReferenceSystem('EPSG:3005'),
                                                          'smax': 10000, '-z': False, '-w': False,
                                                          'output': 'TEMPORARY_OUTPUT',
                                                          'GRASS_REGION_PARAMETER': None,
                                                          'GRASS_SNAP_TOLERANCE_PARAMETER': -1,
                                                          'GRASS_MIN_AREA_PARAMETER': 0.0001,
                                                          'GRASS_OUTPUT_TYPE_PARAMETER': 0,
                                                          'GRASS_VECTOR_DSCO': '',
                                                          'GRASS_VECTOR_LCO': '',
                                                          'GRASS_VECTOR_EXPORT_NOCAT': False})['output']

            allFlightLines = processing.run("native:savefeatures", {
                'INPUT': allFlightLines_Projected,
                'OUTPUT': os.path.join(projectFolder, 'allFlightLines'), 'LAYER_NAME': '',
                'DATASOURCE_OPTIONS': '', 'LAYER_OPTIONS': ''})
            feedback.setProgressText(f'Reprojected allFlightLines')

            # ===========================================================================
            # Add and calculate Height Range field to pointLessthan500m_Projected
            # ===========================================================================
            heightRangeField = processing.run("native:fieldcalculator",
                                 {'INPUT': pointLessthan500m_Projected,
                                  'FIELD_NAME': 'HeightRange',
                                  'FIELD_TYPE': 2,
                                  'FIELD_LENGTH': 100,
                                  'FIELD_PRECISION': 0,
                                  'FORMULA': 'case\nwhen "AGL" < 400 then \'0 to 400m\'\nelse \'400 to 500m\'\nend ',
                                  'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']

            feedback.setProgressText(f'Height Range field calculated')

            # ===========================================================================
            # Refactor the required fields from uwrbuffered layer that created previously
            # ===========================================================================

            uwr_fieldMapping = processing.run("native:refactorfields",
                                              {'INPUT':uwrBufferedPath,
                                               'FIELDS_MAPPING':[
                                                   {'expression': f"{unit_no}",'length': 14,'name': 'UWR_NUMBER','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                   {'expression': f"{unit_no_id}",'length': 14,'name': 'UWR_UNIT_N','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                   {'expression': '"uwr_unique_id"','length': 100,'name': 'uwr_unique_id','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                   {'expression': '"BUFF_DIST"','length': 0,'name': 'BUFF_DIST','precision': 0,'sub_type': 0,'type': 6,'type_name': 'double precision'}],
                                               'OUTPUT':os.path.join(delFolder, 'fieldMapping')})['OUTPUT']

            # ===========================================================================
            # Spatial join the pointLessthan500m and the selected uwebuffered field
            # ===========================================================================
            pointLessthan500m_uwrbuffer = processing.run("native:joinattributesbylocation",
                                  {'INPUT':heightRangeField,
                                   'PREDICATE':[0],
                                   'JOIN':uwr_fieldMapping,
                                   'JOIN_FIELDS':[],
                                   'METHOD':0,
                                   'DISCARD_NONMATCHING':True,
                                   'PREFIX':'',
                                   'OUTPUT':os.path.join(delFolder, 'Point_lessthan500Height_uwrbuffer')})['OUTPUT']

            # ==============================================================
            # If table is empty, ie, no point within uwr buffer zones, no need to get a table
            # ==============================================================
            rowCount = processing.run("qgis:basicstatisticsforfields",
                                          {'INPUT_LAYER': pointLessthan500m_uwrbuffer + '|layername=Point_lessthan500Height_uwrbuffer',
                                           'FIELD_NAME': 'time',
                                           'OUTPUT_HTML_FILE': 'TEMPORARY_OUTPUT'})['COUNT']
            if int(rowCount) == 0:
                raise SystemExit("No flight lines intersect with uwr buffers")

            # ==============================================================
            # Add incurring severity according to buffer range
            # ==============================================================
            incursionSeverityField = processing.run("native:fieldcalculator",
                                 {'INPUT': pointLessthan500m_uwrbuffer,
                                  'FIELD_NAME': 'IncursionSeverity',
                                  'FIELD_TYPE': 2,
                                  'FIELD_LENGTH': 100,
                                  'FIELD_PRECISION': 0,
                                  'FORMULA': 'case\r\nwhen "BUFF_DIST"'
                                             + f"= {inUWR_IS} then \'In UWR\'\r\n"
                                             + 'when "BUFF_DIST" '
                                             + f"={high_IS} then \'High\'\r\n"
                                             + 'when "BUFF_DIST" '
                                             + f"= {moderate_IS} then \'Moderate\'\r\n"
                                             + 'when "BUFF_DIST"'
                                             + f"= {low_IS} then \'Low\'\r\nend",
                                  'OUTPUT': os.path.join(projectFolder, 'allFlightPoints')})['OUTPUT']
            feedback.setProgressText(f'{incursionSeverityField} created')

            # ==============================================================
            # Split points of each incursion severity in different layers
            # ==============================================================
            for severity in incursionSeverity:
                name = "Below500m_" + str(severity)
                diffISlyr = processing.run("native:extractbyexpression",
                                           {'EXPRESSION': "IncursionSeverity = '" + str(incursionSeverity[severity]) + "'",
                                            'INPUT': incursionSeverityField,
                                            'OUTPUT': os.path.join(projectFolder, name)})['OUTPUT']
                feedback.setProgressText(f'{diffISlyr} created')
            feedback.setProgressText('---Process completed successfully---')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            #shutil.rmtree(delFolder)
            feedback.setProgressText('Completed')


        total = 100.0 / uwrBuffered.featureCount() if uwrBuffered.featureCount() else 0
        features = uwrBuffered.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return {'allFlightPoints': incursionSeverityField}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2. Flightpath conversion'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return flightPathConvert()

class calGeneralStats(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    projectFolder = 'projectFolder'
    allFlightPoints = 'allFlightPoints'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # uwrBuffered
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.allFlightPoints, self.tr('Input allFlightPoints'), [QgsProcessing.TypeVectorPoint]))



    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        projectFolder = parameters['projectFolder']
        allFlightPoints = parameters['allFlightPoints']
        statsPath = os.path.join(projectFolder, 'allPointsStats')
        delFolder = os.path.join(projectFolder, 'delFolder')
        # ===========================================================================
        # Check if the delFolder exists, and delete it if found
        # ===========================================================================
        if os.path.exists(delFolder):
            try:
                shutil.rmtree(delFolder)
                os.mkdir(delFolder)
            except:
                feedback.setProgressText('unable to delete delFolder')
        else:
            os.mkdir(delFolder)

        try:
            allFlightPointsStats_temp = processing.run("qgis:statisticsbycategories", {
                'INPUT': allFlightPoints,
                'VALUES_FIELD_NAME': 'TimeInterval',
                'CATEGORIES_FIELD_NAME': ['NameTkline', 'FlightName', 'TotalTime', 'HeightRange', 'UWR_NUMBER', 'UWR_UNIT_N',
                                          'BUFF_DIST', 'IncursionSeverity', "TimeInterv"],
                'OUTPUT': os.path.join(delFolder, 'statsTemp')})['OUTPUT']

            allFlightPointsStats_fieldMapping = processing.run("native:refactorfields",
                                                        {'INPUT':allFlightPointsStats_temp,
                                                         'FIELDS_MAPPING':[
                                                             {'expression': '"NameTkline"','length': 21,'name': 'NameTkline','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"FlightName"','length': 34,'name': 'FlightName','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"TotalTime"','length': 0,'name': 'TotalTime','precision': 0,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                             {'expression': '"HeightRange"','length': 100,'name': 'HeightRange','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"UWR_NUMBER"','length': 14,'name': 'UWR_NUMBER','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"UWR_UNIT_N"','length': 14,'name': 'UWR_UNIT_N','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"BUFF_DIST"','length': 0,'name': 'BUFF_DIST','precision': 0,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                             {'expression': '"IncursionSeverity"','length': 100,'name': 'IncursionSeverity','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"TimeInterv"', 'length': 0,'name': 'TimeInterv', 'precision': 0, 'sub_type': 0,'type': 6, 'type_name': 'double precision'},
                                                             {'expression': '"count"','length': 0,'name': 'Frequency','precision': 0,'sub_type': 0,'type': 2,'type_name': 'integer'}],
                                                         'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']
            allFlightPointsStats_final = processing.run("native:fieldcalculator", {'INPUT':allFlightPointsStats_fieldMapping,
                                                                              'FIELD_NAME':'TotalIncursionTime',
                                                                              'FIELD_TYPE':0,
                                                                              'FIELD_LENGTH':100,
                                                                              'FIELD_PRECISION':2,
                                                                              'FORMULA':' "Frequency" * "TimeInterv" ',
                                                                              'OUTPUT':statsPath})['OUTPUT']

            lyr = QgsVectorLayer(allFlightPointsStats_final, 'allFlightPointStats', "ogr")

            QgsVectorFileWriter.writeAsVectorFormat(lyr, statsPath ,"utf-8",driverName = "XLSX", layerOptions = ['GEOMETRY=AS_XYZ'])


            feedback.setProgressText('---Process completed successfully---')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            feedback.setProgressText('Completed')


        total = 100.0 / lyr.featureCount() if lyr.featureCount() else 0
        features = lyr.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return {'allFlightPointsStats': allFlightPointsStats_final}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '3. Calculate General Stats'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return calGeneralStats()

class LOS_analysis(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    projectFolder = 'projectFolder'
    uwrBuffered = 'uwrBuffered'
    #maxBufferRange = 'maxBufferRange'
    DEM = 'DEM'
    allFlightPoints = 'allFlightPoints'
    unit_id = 'unit_id'
    unit_id_no = 'unit_id_no'
    viewshed = 'viewshed'
    minElevViewshed = 'minElevViewshed'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # uwrBuffered
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.uwrBuffered, self.tr('Input uwrBuffered'), [QgsProcessing.TypeVectorPolygon]))
        # ===========================================================================
        # unit_id / unit_id_no - Input string
        # User selects from the field list derived from OrigUWR
        # ===========================================================================
        self.addParameter(QgsProcessingParameterField(
            self.unit_id, self.tr('Input unit id field, column has text like u-2-002'), 'unit_id', self.uwrBuffered))

        self.addParameter(QgsProcessingParameterField(
            self.unit_id_no, self.tr('Input unit id number field, column has text like Mg-059'), 'unit_id', self.uwrBuffered))
        # ===========================================================================
        # max buffer range
        # ===========================================================================
        #self.addParameter(QgsProcessingParameterString(
        #    self.maxBufferRange, self.tr('Max Buffer Range'), 1500))
        # ===========================================================================
        # allFlightPoints (created from flightpath conversion)
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.allFlightPoints, self.tr('Input allFlightPoints'), [QgsProcessing.TypeVectorPoint]))
        # ===========================================================================
        # DEM
        # ===========================================================================
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.DEM, self.tr('Input the project DEM')))
        # ===========================================================================
        # viewshed
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.viewshed, self.tr('Existed viewshed'), [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.minElevViewshed, self.tr('Existed minElevViewshed'), [QgsProcessing.TypeVectorPolygon]))



    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        projectFolder = parameters['projectFolder']
        uwrBuffered = parameters['uwrBuffered']
        uwrBuffered_source = self.parameterAsSource(parameters, self.uwrBuffered, context)
        #maxBuffRange = parameters['maxBufferRange']
        allFlightPoints = parameters['allFlightPoints']
        DEM = parameters['DEM']
        existedViewshed = parameters['viewshed']
        existedMinElevViewshed = parameters['minElevViewshed']
        delFolder = os.path.join(projectFolder, 'delFolder')
        # ===========================================================================
        # Check if the delFolder exists, and delete it if found
        # ===========================================================================
        if os.path.exists(delFolder):
            try:
                shutil.rmtree(delFolder)
                os.mkdir(delFolder)
            except:
                feedback.setProgressText('unable to delete delFolder')
        else:
            os.mkdir(delFolder)

        try:
            feedback.setProgressText(f'{projectFolder}')
            feedback.setProgressText(f'{uwrBuffered}')
            #feedback.setProgressText(f'{maxBuffRange}')
            feedback.setProgressText(f'{allFlightPoints}')
            feedback.setProgressText(f'{DEM}')
            feedback.setProgressText(f'{existedViewshed}')
            feedback.setProgressText(f'{existedMinElevViewshed}')

            # ==============================================================
            # unit_no, eg. u-2-002
            # unit_no_id, eg. Mg-106
            # unit_unique_field, field that combines uwr number and uwr unit number
            # ==============================================================
            unit_no = parameters['unit_id']
            unit_no_id = parameters['unit_id_no']
            uwr_unique_Field = 'uwr_unique'

            # ==============================================================
            # Get list of relevant UWR
            # ==============================================================
            uwrFieldList = uwrBuffered_source.fields().names()
            unit_no_index = uwrFieldList.index(unit_no)
            unit_no_id_index = uwrFieldList.index(unit_no_id)
            feedback.setProgressText(f'{unit_no_id_index, unit_no_index}')
            uwrSet = set()
            for feature in uwrBuffered_source.getFeatures():
                uwr_unique_Field_value = f'{feature.attributes()[unit_no_index]}__{feature.attributes()[unit_no_id_index]}'
                uwrSet.add(uwr_unique_Field_value)
            feedback.setProgressText(f'{uwrSet}')

            # ==============================================================
            # Get list of uwr that have viewshed created
            # ==============================================================
            viewshedUWRset = set()
            UWRRequireViewshedSet = None
            if existedViewshed != None:
                viewshed_source = self.parameterAsSource(parameters, self.viewshed, context)
                viewshedFieldList = viewshed_source.fields().names()
                uwr_unique_Field_index = viewshedFieldList.index('uwr_unique')
                feedback.setProgressText(f'{uwr_unique_Field_index}')
                for feature in viewshed_source.getFeatures():
                    uwr_unique_Field_value = f'{feature.attributes()[uwr_unique_Field_index]}'
                    viewshedUWRset.add(uwr_unique_Field_value)
                UWRRequireViewshedSet = uwrSet - viewshedUWRset
            else:
                UWRRequireViewshedSet = uwrSet
                feedback.setProgressText(f'No existed viewshed layer')

            # ==============================================================
            # Create viewshed for uwr that doesn't have any. Either makes a new final viewshed or appends to the old one
            # ==============================================================
            if len(UWRRequireViewshedSet) > 0:
                feedback.setProgressText(f'No existed viewshed layer')
                #ext = makeViewshed(UWRRequireViewshedSet, uwrBuffered, maxBuffRange, unit_no, unit_no_id, uwr_unique_Field, delFolder, DEM, existedViewshed, existedMinElevViewshed)
                feedback.setProgressText(f'{UWRRequireViewshedSet}')
                exit()

            else:
                feedback.setProgressText('No need to make viewsheds')

            # ==============================================================
            #
            # ==============================================================
            finalPointsSet = set()

            # ==============================================================
            # Count of points intersecting with the viewshed for each UWR
            # ==============================================================
            viewshedPointCount = {}

            # ==============================================================
            # List of layers with points that are not terrain masked
            # ==============================================================
            uwr_notmasked_List = []

            for uwr in uwrSet:
                nameUWR = replaceNonAlphaNum(uwr, "_")
                points_aglViewshed = 'points_aglViewshed' + nameUWR
                uwr_notmasked = 'notMasked' + nameUWR
                feedback.setProgressText('Finding LOS flight points fpr uwr')
                LOS_uwrFlightPointsLyr = 'LOS_uwrFlightPoints'
                uwrPointsStatsTime = datetime.datetime.now()
                uwrFlightPointsSet = set()
                NotLOSSet = set()

                uwr_no = uwr[:uwr.find("__")]
                uwr_no_id = uwr[uwr.find("__") + 2:]

                # ==============================================================
                # Check to find the right query depending on if uwr fields are integer or text
                # ==============================================================
                minElevViewshedLyr = QgsVectorLayer((existedMinElevViewshed), "", "ogr")
                expression = None
                for feature in minElevViewshedLyr.getFeatures():
                    minElevViewshedLyr_fields = minElevViewshedLyr.fields().names()
                    unit_no_index = minElevViewshedLyr_fields.index(unit_no)
                    unit_no_attribute = feature.attributes()[unit_no_index]
                    unit_no_id_index = minElevViewshedLyr_fields.index(unit_no_id)
                    unit_no_id_attribute = feature.attributes()[unit_no_id_index]

                    if type(unit_no_attribute) == int:
                        expression = '(\"' + unit_no + '\" = ' + uwr_no + ')'
                    else:
                        expression = '(\"' + unit_no + '\" = \'' + uwr_no + "')"

                    if type(unit_no_id_attribute) == int:
                        expression += ' AND (\"' + unit_no_id + '\" = ' + uwr_no_id + ')'
                    else:
                        expression += ' AND (\"' + unit_no_id + '\" = \'' + uwr_no_id + "')"

                    break

                minElevViewshedLyr_selected = processing.run("native:extractbyexpression",
                                                     {'EXPRESSION': expression + " AND (gridcode <> 0)",
                                                      'INPUT': minElevViewshedLyr,
                                                      'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
                feedback.setProgressText(f'minElevViewshed_Lyr_selected')

                uwrFlightPoints_selected = processing.run("native:extractbyexpression",
                                                     {'EXPRESSION': expression,
                                                      'INPUT': allFlightPoints,
                                                      'OUTPUT': os.path.join(delFolder, 'uwrFlightPoints_selected')})['OUTPUT']
                feedback.setProgressText(f'uwrFlightPoints_selected')
                # ==============================================================
                # all flight points associated with the UWR
                # ==============================================================
                uwrFlightPoints_selectedLyr = QgsVectorLayer((uwrFlightPoints_selected), "", "ogr")
                for feature in uwrFlightPoints_selectedLyr.getFeatures():
                    uwrFlightPoints_selectedLyr_fields = uwrFlightPoints_selectedLyr.fields().names()
                    fidIndex = uwrFlightPoints_selectedLyr_fields.index('fid')
                    fid_attribute = feature.attributes()[fidIndex]
                    uwrFlightPointsSet.add(fid_attribute)
                feedback.setProgressText(f'uwrFlightPointsSet: {uwrFlightPointsSet}')

                # ==============================================================
                # Spatial join points with points that aren't in the direct viewshed but within the buffer zone
                # ==============================================================
                poisAglViewshed = processing.run("native:joinattributesbylocation",
                               {'INPUT':uwrFlightPoints_selected ,
                                'PREDICATE': [0],
                                'JOIN': minElevViewshedLyr_selected,
                                'JOIN_FIELDS': [], 'METHOD': 2, 'DISCARD_NONMATCHING': False, 'PREFIX': '',
                                'OUTPUT': os.path.join(delFolder, 'pointAGL')})['OUTPUT']

                # ==============================================================
                # Getting the points that are terrain masked
                # ==============================================================
                points_aglViewshed_NumSet = set()
                poisAglViewshedLyr = QgsVectorLayer((poisAglViewshed), "", "ogr")
                for feature in poisAglViewshedLyr.getFeatures():
                    poisAglViewshedLyr_fields = poisAglViewshedLyr.fields().names()
                    fidIndex = poisAglViewshedLyr_fields.index('fid')
                    fid_attribute = feature.attributes()[fidIndex]
                    aglIndex = poisAglViewshedLyr_fields.index('AGL')
                    agl_attribute = feature.attributes()[aglIndex]
                    gridcodeIndex = poisAglViewshedLyr_fields.index('gridcode')
                    gridcode_attribute = feature.attributes()[gridcodeIndex]
                    if gridcode_attribute is not None and agl_attribute < gridcode_attribute:
                        points_aglViewshed_NumSet.add(str(fid_attribute))
                feedback.setProgressText(f'points_aglViewshed_NumSet: {points_aglViewshed_NumSet}')

                if len(points_aglViewshed_NumSet) == 0:
                        finalSQL = None

                else:
                    terrainMaskPoi = ','.join(points_aglViewshed_NumSet)
                    finalSQL = "fid NOT IN (" + terrainMaskPoi + ")"

                uwr_notmasked_selected = processing.run("native:extractbyexpression",
                                                        {'EXPRESSION': finalSQL,
                                                         'INPUT': poisAglViewshed,
                                                         'OUTPUT': os.path.join(delFolder, uwr_notmasked)})['OUTPUT']

                # ==============================================================
                # Put into a list of all the layers of points that are terrain masked
                # ==============================================================
                uwr_notmasked_List.append(uwr_notmasked_selected)
                feedback.setProgressText(f'{uwr_notmasked_selected}')

            # ==============================================================
            # Create final layer of all points that aren't terrain masked
            # ==============================================================
            nonTerrainMaskedPoi_merge = processing.run("native:mergevectorlayers",
                                               {'LAYERS': uwr_notmasked_List,
                                                'CRS': None,
                                                'OUTPUT': os.path.join(delFolder, 'LOS_uwrFlightPoints')})['OUTPUT']

            feedback.setProgressText('Merged all non terrain masked points together')

            # ==============================================================
            # Get count of points that are in direct viewshed
            # ==============================================================
            LOS_uwrFlightPoints_selected = processing.run("native:extractbyexpression",
                                                    {'EXPRESSION': " gridcode is Null ",
                                                     'INPUT': nonTerrainMaskedPoi_merge,
                                                     'OUTPUT': os.path.join(delFolder, 'LOS_uwrFlightPoints_selected')})['OUTPUT']

            poi_underDirectViewshed_count = processing.run("qgis:basicstatisticsforfields", {
                'INPUT_LAYER': LOS_uwrFlightPoints_selected,
                'FIELD_NAME': 'OBJECTID', 'OUTPUT_HTML_FILE': 'TEMPORARY_OUTPUT'})['COUNT']
            feedback.setProgressText(f'Points under direct viewshed: {poi_underDirectViewshed_count}')
            viewshedPointCount[uwr] = poi_underDirectViewshed_count

            # ==============================================================
            # Getting count found in direct viewshed into excel
            # ==============================================================
            dfViewshed = pd.DataFrame.from_dict(viewshedPointCount, orient='index')
            dfViewshed.columns = ['points found in viewshed']
            feedback.setProgressText(f'ViewshedPointCount: {viewshedPointCount}')
            dfViewshed.to_excel(os.path.join(projectFolder, 'ViewshedPointCount.xlsx'))
            feedback.setProgressText(f'ViewshedPointCount.xlsx created in {projectFolder}')

            feedback.setProgressText('---Process completed successfully---')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            feedback.setProgressText('Completed')


        total = 100.0 / uwrBuffered.featureCount() if uwrBuffered.featureCount() else 0
        features = uwrBuffered.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return {'allFlightPointsStats': None}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '4. LOS Analysis'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LOS_analysis()

class finalPointsStats(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    projectFolder = 'projectFolder'
    LOS_finalPoints = 'LOS_finalPoints'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # uwrBuffered
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.LOS_finalPoints, self.tr('Input LOS_finalPoints'), [QgsProcessing.TypeVectorPoint]))



    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        projectFolder = parameters['projectFolder']
        LOS_finalPoints = parameters['LOS_finalPoints']
        statsPath = os.path.join(projectFolder, 'finalPointsStats')
        delFolder = os.path.join(projectFolder, 'delFolder')
        # ===========================================================================
        # Check if the delFolder exists, and delete it if found
        # ===========================================================================
        if os.path.exists(delFolder):
            try:
                shutil.rmtree(delFolder)
                os.mkdir(delFolder)
            except:
                feedback.setProgressText('unable to delete delFolder')
        else:
            os.mkdir(delFolder)

        try:
            # ==============================================================
            # unit_no, eg. u-2-002
            # unit_no_id, eg. Mg-106
            # unit_unique_field, field that combines uwr number and uwr unit number
            # ==============================================================
            unit_no = "UWR_NUMBER"
            unit_no_id = "UWR_UNIT_NUMBER"
            uwr_unique_Field = "uwr_unique"

            LOS_finalPointsStats_temp = processing.run("qgis:statisticsbycategories", {
                'INPUT': LOS_finalPoints,
                'VALUES_FIELD_NAME': 'TimeInterval',
                'CATEGORIES_FIELD_NAME': ['NameTkline', 'FlightName', 'TotalTime', 'HeightRange', 'UWR_NUMBER', 'UWR_UNIT_N',
                                          'BUFF_DIST', 'IncursionSeverity', "TimeInterv"],
                'OUTPUT': os.path.join(delFolder, 'LOS_statsTemp')})['OUTPUT']

            LOS_finalPointsStats_fieldMapping = processing.run("native:refactorfields",
                                                        {'INPUT':LOS_finalPointsStats_temp,
                                                         'FIELDS_MAPPING':[
                                                             {'expression': '"NameTkline"','length': 21,'name': 'NameTkline','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"FlightName"','length': 34,'name': 'FlightName','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"TotalTime"','length': 0,'name': 'TotalTime','precision': 0,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                             {'expression': '"HeightRange"','length': 100,'name': 'HeightRange','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"UWR_NUMBER"','length': 14,'name': 'UWR_NUMBER','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"UWR_UNIT_N"','length': 14,'name': 'UWR_UNIT_N','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"BUFF_DIST"','length': 0,'name': 'BUFF_DIST','precision': 0,'sub_type': 0,'type': 6,'type_name': 'double precision'},
                                                             {'expression': '"IncursionSeverity"','length': 100,'name': 'IncursionSeverity','precision': 0,'sub_type': 0,'type': 10,'type_name': 'text'},
                                                             {'expression': '"sum"','length': 0,'name': 'TimeInterv','precision': 0,'sub_type': 0,'type': 2,'type_name': 'integer'}],
                                                         'OUTPUT':'TEMPORARY_OUTPUT'})['OUTPUT']


            lyr = QgsVectorLayer(LOS_finalPointsStats_fieldMapping, 'LOS_finalPointsStats', "ogr")

            QgsVectorFileWriter.writeAsVectorFormat(lyr, statsPath ,"utf-8",driverName = "XLSX", layerOptions = ['GEOMETRY=AS_XYZ'])


            feedback.setProgressText('---Process completed successfully---')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            feedback.setProgressText('Completed')


        total = 100.0 / lyr.featureCount() if lyr.featureCount() else 0
        features = lyr.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return {'LOS_finalPointsStats': LOS_finalPointsStats_fieldMapping}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '5. LOS Final Points Stats'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return finalPointsStats()


class flightPathAnalysis(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.
    projectFolder = 'projectFolder'
    origUWR = 'origUWR'
    unit_id = 'unit_id'
    unit_id_no = 'unit_id_no'
    gpxFolder = 'gpxFolder'
    DEM = 'DEM'
    buffDistIS_high = 'buffDistIS_high'
    buffDistIS_moderate = 'buffDistIS_moderate'
    buffDistIS_low = 'buffDistIS_low'
    viewshed = 'viewshed'
    minElevViewshed = 'minElevViewshed'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        # ===========================================================================
        # Project Folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.projectFolder, self.tr('Project Folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # OrigUWR - Input vector polygon
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.origUWR, self.tr('Input original UWR'), [QgsProcessing.TypeVectorPolygon]))
        # ===========================================================================
        # unit_id / unit_id_no - Input string
        # User selects from the field list derived from OrigUWR
        # ===========================================================================
        self.addParameter(QgsProcessingParameterField(
            self.unit_id, self.tr('Input unit id field, column has text like u-2-002'), 'unit_id', self.origUWR))

        self.addParameter(QgsProcessingParameterField(
            self.unit_id_no, self.tr('Input unit id number field, column has text like Mg-059'), 'unit_id',
            self.origUWR))
        # ===========================================================================
        # gpx - Input Folder
        # will loop through all the gpx files under the folder
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFile(
            self.gpxFolder, self.tr('Input gpx folder'), QgsProcessingParameterFile.Folder))
        # ===========================================================================
        # DEM
        # ===========================================================================
        self.addParameter(QgsProcessingParameterRasterLayer(
            self.DEM, self.tr('Input the project DEM')))
        # ===========================================================================
        # viewshed
        # ===========================================================================
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.viewshed, self.tr('Existed viewshed'), [QgsProcessing.TypeVectorPolygon]))
        self.addParameter(QgsProcessingParameterFeatureSource(
            self.minElevViewshed, self.tr('Existed minElevViewshed'), [QgsProcessing.TypeVectorPolygon]))

        # ===========================================================================
        # bufferDistIS_high/moderate/low - Input string, with default value 500/1000/1500
        # three buffer range represents different incursion severity range
        # ===========================================================================
        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_high, self.tr('Buffer distance - High Incursion Severity'), 500))

        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_moderate, self.tr('Buffer distance - Moderate Incursion Severity'), 1000))

        self.addParameter(QgsProcessingParameterString(
            self.buffDistIS_low, self.tr('Buffer distance - Low Incursion Severity'), 1500))


    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve the feature source and sink. The 'dest_id' variable is used
        # to uniquely identify the feature sink, and must be included in the
        # dictionary returned by the processAlgorithm function.
        projectFolder = parameters['projectFolder']
        LOS_finalPoints = parameters['LOS_finalPoints']
        statsPath = os.path.join(projectFolder, 'finalPointsStats')
        delFolder = os.path.join(projectFolder, 'delFolder')
        # ===========================================================================
        # Check if the delFolder exists, and delete it if found
        # ===========================================================================
        if os.path.exists(delFolder):
            try:
                shutil.rmtree(delFolder)
                os.mkdir(delFolder)
            except:
                feedback.setProgressText('unable to delete delFolder')
        else:
            os.mkdir(delFolder)

        try:
            # ==============================================================
            # unit_no, eg. u-2-002
            # unit_no_id, eg. Mg-106
            # unit_unique_field, field that combines uwr number and uwr unit number
            # ==============================================================
            unit_no = "UWR_NUMBER"
            unit_no_id = "UWR_UNIT_NUMBER"
            uwr_unique_Field = "uwr_unique"

            feedback.setProgressText('---Process completed successfully---')

        except QgsException as e:
            feedback.setProgressText('Something is wrong')
            feedback.setProgressText(f'{e}')

        finally:
            feedback.setProgressText('Completed')


        total = 100.0 / lyr.featureCount() if lyr.featureCount() else 0
        features = lyr.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break

            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.

        return None

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'WHOLE PROCESS - Flightpath Analysis'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return '2023_Project'

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return flightPathAnalysis()